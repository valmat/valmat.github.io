---
title: "php Cacher"
date: 2010-10-30T10:48:00Z
draft: false
tags: ["archive", "php", "github"]
# filename: "php-cacher"
# catigories: ["php", "github"]
---

Опубликовал набор классов для кеширования:  
[http://github.com/valmat/Cacher](http://github.com/valmat/Cacher)  
Опубликовано под лицензией  
GPL v.3 ([http://www.gnu.org/licenses/gpl.txt](http://www.gnu.org/licenses/gpl.txt))  
То есть свободно для использования и изменения. Разумеется, приветствуются любые исправления и дополнения.

## Назначение

Мне нужен был очень простой, но в то же время мощный кеширующий модуль с понятной логикой. При этом он должен быть пригодным для работы на односерверном, но в то же время нагруженном проекте.

Также немаловажным моментом является возможность прозрачно менять стратегию кеширования в зависимости от текущего уровня нагрузки проекта.

То есть решение должно удовлетворять требованию изменять стратегию кеширования по мере роста нагрузки на проект и по мере изменения аппаратных возможностей (речь об ОЗУ) сервера.

## Архитектура

Основными логическими единицами являются:

- **Cacher** — фронтенд к кеширующим классам.
- **Cacher_Backend** — собственно сами кеширующие классы.
- **Слоты** — кеширование и доступ к кешу осуществляется через слоты.
- **Теги** — для упрощения управления кешем и, главным образом, для переуеширования.
- **Типы кеширования** — для прозрачного изменения стратегии кеширования. То есть конкретный кеширующий бекенд подключается только через слот (или тег), которые, в свою очередь, оперируют типами. Таким образом, для изменения стратегии кеширования нужно всего лишь поменять привязку типов к бекендам.

## Использование

### class Cacher

Требует наличия классов, унаследованных от Cacher_Backend — семейство классов, реализующих бэкэнд для класса Cacher.

Все операции с кешем осуществляются на низшем уровне через тот или иной бекенд.

Бэкэндом может быть файловая система, shared memory, memcache, Sqlite и другие системы кеширования.

Для работы с классом используются слоты и теги. Слоты реализованы в виде набора дружественных функций и неявно зашиты в интерфейс текущего класса.

#### Пример использования

```php
define AnyObj // может быть класс, массив или другой объект. 
// На основании этого объекта слот-функция вычислит ключ и, возможно, другие параметры (бэкэнд и время жизни).
Cacher::Slot('AniObj', AniObj); // Инициализируем слот кеширования. Первый параметр — имя слота, второй — наш объект

// Получаем данные
if (false === ($CacheData = Cacher::get())) { // Если данные из кеша получить не удалось...
    $CacheData = GetFromAnyExternal(); // Получаем данные из внешнего хранилища
    Cacher::addTag(Cacher::newTag('AniTagData', AniTagDataObj)); // Создаем и сразу же добавляем новый тег к слоту перед сохранением в кеш
    $tag2 = Cacher::newTag('AniTagData2', AniTagDataObj1); // Создаем новый тег
    Cacher::addTag($tag2); // Добавляем новый тег к слоту перед сохранением в кеш
    Cacher::set($CacheData); // Кешируем данные
}
// ...
// Если затем нужно сбросить какой-нибудь тег, то нужно будет сделать так:
Cacher::newTag('AniTagData2', AniTagDataObj1)->clear(); // Очищаем кеш тега
